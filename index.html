<!doctype html>
<meta charset="utf-8"/>

<title>The Future of Federation</title>
<link rel=stylesheet href=base.less>
<link rel=stylesheet href=intro.less>
<link rel=stylesheet href=constellation.less>
<link rel=stylesheet href=feat.less>
<script src=elements.ts></script>

<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@600;700" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@600;700" rel="stylesheet">

<div id=backdrop></div>
<div id=graph></div>
<div id=explosion></div>

<script src=main.js></script>

<style>
  .hljs { background: none; }
</style>
<script src=graphql.ts></script>

<build-note id=title>
hi, i'm ashi krishnan, i work at apollo, and i'm here to talk about the future of federation.

we've been doing a lot of work over the last year, all aimed at making it easier for you to weave together many large graphs and end up with exactly the data you need, in exactly the shape you need it. after all, that's the promise of graphql.

first, let's look at the state of graphql and federation today.
</build-note>

<build-note id=introCommonLanguage>
  graphql gives us a common language to describe all the data available through an API. say we're an organization who launches people into space. we'll presumably have a database tracking who we have launched (or will launch) into space. and then we'll write a graphql schema to expose that data for our website where you can see who we've launched into space. the graphql schema might look like this:
</build-note>

<pre id=spaceySchema>
<code class=graphql>
  type Query {
    launches: [Launch!]!
    astronaut(byName: String!): Astronaut
    missions: [Mission!]!
    ships: [Ship!]!
  }

  type Launch {
    id: ID!
    site: String
    mission: Mission
    ship: Ship
    astronauts: [Astronaut]!
  }
  
  type Ship {
    id: ID!
    name: String
    type: String
  }
 
  type Astronaut {
    id: ID!
    name: String!    
    trips: [Launch]!
  }
  
  type Mission {
    name: String
  }
</code>
</pre>

<build-note id=introSpaceySchema>
  this looks like a tree, but when we parse it, we can see that it creates a structure with cross-links—
</build-note>

<script>
  EMPTY = {nodes: [], links: []}
  When(buildInRange(title, introSpaceySchema))
    .start(() => Graph.graphData(EMPTY))
</script>

<build-note id=introSpaceyGraph>
  —that is, it gets linked into a graph.
</build-note>

<build-note id=introSpaceyGraphOrbit>
  in this graph, types are nodes—they are places you can *be*. fields are edges—they are ways you can *move*. resolvers teach us *how to walk along an edge*.
</build-note>

<pre id=bookishSchema>
  <code class=graphql>
    type Query {
      books(forAstronaut: ID!): [Book]
    }
    
    type Book {
      title: String
      author: Author
      themes: [String!]
    }
    
    type Author {
      name: String
      books: [Book!]
    }
  </code>
</pre>

<pre id=spaceyQuery>
  <code class=graphql>
    query {
      astronaut(byName: "Sally") {
        trips {
          mission { name }
        }
      }
    }
  </code>
</pre>

<build-note id=introSpaceyQuery>
  so when we receive a query
</build-note>
<build-note id=introSpaceyRunQuery>
  the resolvers know how to take us to the data

  if we didn't have graphql, we would still be able to expose this data. we'd just have to come up with our own interface to request it—maybe some RESTful api. 

  but graphql gives us a common language for expressing our schema. that common language makes it easier to get data out of graphql endpoints. it also means that endpoints can be merged together and treated as a single graph.

  after we've been launching people into space for a while, we notice that most of the people who want to go to space are sci-fi fans, so we want to roll out a feature where we track what folks are reading and use it to inspire future missions. this project is run by a separate team, so they produce a separate schema:
</build-note>
<build-note id=introBookishSchema>
  which links into another graph
</build-note>

<script>
  spacey = {
    schema: parseToGraph('spacey', spaceySchema.textContent),
    graph: Atlas.graphData('spacey')
  }
  When(buildInRange(introSpaceyGraph, introSpaceyRunQuery))
    .start(() => Graph.graphData(spacey.graph).clearHighlights().recenter())

  When(buildInRange(introSpaceyGraphOrbit, introSpaceyRunQuery))
    .withDuration(3[sec])
    .at(orbit())

  When(introSpaceyRunQuery)
    .start(() => {
      graphql(spacey.schema, spaceyQuery.innerText)
    }).end(() => Graph.clearHighlights())
</script>

<build-note id=introBookishGraph>
  there's a subtle connection to our space graph here:
</build-note>
<build-note id=introBookishGraphOrbit>
  specifically, we can look up the books for a particular astronaut's ID.  
</build-note>

<script>  
  bookish = {
    schema: parseToGraph('bookish', bookishSchema.textContent),    
    graph: Atlas.graphData('bookish')
  }

  When(buildInRange(introBookishSchema, introBookishGraphOrbit))
    .start(() => {
      Graph.graphData(bookish.graph).recenter()
        .clearHighlights()
    })

  When(introBookishGraphOrbit)
    .withDuration(3[sec])
    .at(orbit())
</script>

<build-note id=introBothGraph>
  but that's not really represented in the graph itself.
</build-note>

<build-note id=introBothGraphOrbit>
  the two graphs are disconnected. so if we want to do a query across them, we have to do that query separately, and manually
</build-note>

<pre id=spaceManualQuery>
  <code class=graphql>
    query GetAstronautId($name: String!) {
      astronaut(byName: $name) { id }
    }

    # variables: { name: "sally" }
  </code>
</pre>

<pre id=bookishManualQuery>
  <code class=graphql>
    query GetAstronautTitles($id: ID!) {
      books(forAstronaut: $id) {
        title
        author { name }
      }
    }
  </code>
</pre>

<build-note id=introManualQuerySpacey>
  first, we query spacey to get the id of an astronaut we're interested in
</build-note>
<build-note id=introRunManualQuerySpacey></build-note>
<build-note id=introManualQueryBookish>
  then we have to shuttle that data over to bookish ourselves to query for the astronaut's titles
</build-note>
<build-note id=introRunManualQueryBookish>
  this gets us the data we need, but it's not exactly ideal. it breaks the graphql promise of making one query to feed your frontend

  federation solves this.
</build-note>

<script>
  When(introRunManualQuerySpacey)
    .start(() => {
      Graph.clearHighlights()
      graphql(spacey.schema, spaceManualQuery.textContent,
        {},
        {},
        { name: "sally" })
    })

  When(introRunManualQueryBookish)
    .start(() => {
      Graph.zoomToFit(300)
      graphql(bookish.schema, bookishManualQuery.textContent,
        {},
        {},
        { id: 0 })
    })
</script>

<build-note id=introFed>
  to link these two graphs with federation, we don't need to change our spacey schema at all
</build-note>

<build-note id=introFedBookish>
  but we do need to make a few changes to our bookish schema. these changes teach the federation gateway how to build *another* graph
</build-note>

<pre id=bookishFedSchema>
  <code class=graphql>
    extend type Query {
      books(forAstronaut: ID!): [Book]
    }

    extend type Astronaut @key(fields: "id") {
      id: ID! @external
      books: [Book]
    }
    
    type Book {
      title: String
      author: Author
      themes: [String!]
    }
    
    type Author {
      name: String
      books: [Book!]
    }
  </code>
</pre>

<build-note id=introFedEarthseed>
  the federated graph
</build-note>

<build-note id=introFedEarthseedOrbit>
  the federated graph joins our other two graphs. you can think of it as a projection of both of them. a pretty faithful one—it contains all the types and fields from all our services, with the same types, names, arguments, and so on.

  it also knows where those types and fields are *from* and, thanks to keys, how to get from one graph to another.
</build-note>

<build-note id=introFedEarthseedQuery>
  now we can express our request as a single query against the federated graph
</build-note>

<build-note id=introFedEarthseedRunQuery>
  and when we run the query the gateway knows what queries to issue against its subgraphs to resolve the data we asked for.

  that's federation as it stands today. federation is already incredibly powerful. it lets you fold multiple graphs into one—it's effectively giving us the "reduce" part of "map/reduce", but for the structure of our data itself. as with mapreduce, this lets you parallelize work—only in this case, the work is *growing the graph*. with federation, you can have multiple teams each working on growing the graph—it grows in parallel.

  which means, your graph can explode.
</build-note>

<pre id=earthseedQuery>
  <code class=graphql>
    query {
      astronaut(byName: "sally") {
        books {
          title
          author { name }
        }
      }
    }
  </code>
</pre>

<script>
  spaceyAndBookish = Atlas.graphData('spacey', 'bookish')

  When(buildInRange(introBothGraph, introFed))
    .start(() => Graph.graphData(spaceyAndBookish).recenter().clearHighlights())

  When(buildInRange(introBothGraphOrbit, introFed))
    .withDuration(3[sec])
    .at(orbit())

  // parseToGraph(fedAtlas, 'bookish', bookishFedSchema.textContent)
  // parseToGraph(fedAtlas, 'spacey', spaceySchema.textContent)

  When(introFedBookish)
    .start(() => Graph.recenter().clearHighlights())
    
  fedSpaceyBookish = composeServices([
    {
      name: 'spacey',
      typeDefs: gql.call(null, [spaceySchema.textContent]),      
    },
    {
      name: 'bookish',
      typeDefs: gql.call(null, [bookishFedSchema.textContent]),
    }
  ])
  
  earthseed = {
    schema: parseToGraph('earthseed', fedSpaceyBookish.schema),
    graph: Atlas.graphData()
  }
  
  // spaceyBookishEarthseed = {
  //   nodes: [...spacey.nodes, ...bookish.nodes, ...earthseed.nodes],
  //   links: [...spacey.links, ...bookish.links, ...earthseed.links],
  // }
  
  When(buildInRange(introFedEarthseed, introFedEarthseedRunQuery))
    .start(() => {
      Graph.graphData(earthseed.graph).recenter().clearHighlights()
    })

  When(introFedEarthseedRunQuery)
    .start(async () => {
      await graphql(earthseed.schema, spaceManualQuery.textContent,
        {},
        {},
        { name: "sally" })
      graphql(earthseed.schema, earthseedQuery.textContent)
    })

  When(buildInRange(introFedEarthseedOrbit, introFedEarthseedRunQuery))
    .withDuration(3[sec])
    .at(orbit())
</script>


<build-note id=csExplode>
  this is amazing, but it can also be a lot! the amount of accessible data in your organization and frankly in the world is enough to make anyone's brain start dropping frames just like my computer.
  
  massive graphs create new, massive problems. you still have one graph to reason about, but now it's made of tens or hundreds of subgraphs, each likely maintained by a separate team. you have to make sure they fit together, make sure nobody steps on anyone else's toes.
  
  there are also some use cases that federation doesn't handle yet. when we federate graphs today, we end up with a federated graph that looks a lot like our subgraphs. same names, same types, same fields. but what if we want to change that? what if we want more flexibility in how we merge our graphs together?

  some of you might remember schema stitching—some of you might *still be using* schema stitching. schema stitching was kindof a precursor to federation: a more bare-metal way of merging subgraphs together. with schema stitching, you could really do whatever you wanted to the subgraphs, pruning and reshaping fields, changing types. but schema stitching was very ad-hoc—literally, you write some javascript that manipulates the schema ASTs more or less directly. that's extremely flexible, but also quite hard to reason about. with federation, we can and do run validations on the composed graph. schema stitching doesn't really allow for that, because outside of the requirement that it be a valid graphql schema, we really have no way of knowing if the stitched schema is correct.

  what if we could have both? the verifiability of federation with the flexibility of schema stitching?
</build-note>

<script>
  splode = addBloom(ForceGraph3D()(explosion))
    .nodeRelSize(1)
    .enableNavigationControls(false)
    .showNavInfo(false)    
</script>

<div id=whatsNext>
  <type-writer id=whatsNextTxt></type-writer>
</div>

<build-note id=csEarlier>
  earlier this year, we sat down and asked ourselves this question: what's next? how do build on federation? how do we develop tools to wrangle these increasingly massive graphs?
</build-note>

<build-note id=csWhatsNext>
  we've called the result project constellation.
</build-note>

<build-note id=csEvolution>
  project constellation is an evolution of federation, developed with a few goals in mind
</build-note>

<build-note id=csFaster>
  we knew we wanted to improve performance
</build-note>

<build-note id=csRust>
  to that end, we're rewriting the query planner in rust. this doesn't mean *you* have to write anything in rust; it also doesn't mean we've given up on javascript. our intention here is to provide a drop-in replacement for the current query planner within apollo server. when it's ready, all you'll have to do is update your gateway to get the benefits.

  now, we're not just dropping in rust and expecting things to get faster. 
</build-note>

<build-note id=csParallelism>
  we're also doing a lot of testing. we're building out benchmarks and using them to explore design patterns that can exploit the many, many cores today's servers are stacked with
</build-note>

<build-note id=csAheadOfTime>
  longer term, we're developing workflows to reduce the work the gateway does—such as schema composition—by moving it to an ahead of time compilation step
</build-note>

<build-note id=csStronger>
  that ties into our next goal, which is to make federation *stronger*
</build-note>

<build-note id=csValidations>
  we'd like to be able to provide better validation information earlier in the development process
</build-note>

<build-note id=csErrors>
  when you're working on some part of your graph, you should be able to compile the whole thing during development, locally, and see if there are any problems
</build-note>

<build-note id=csInsight>
  and the tools to make that possible will give you a lot more insight than you have today into how the graph of everything liks together  
</build-note>

<build-note id=csFlexiblier>
  that's important, because we're also making federation flexibili...er 
</build-note>

<build-note id=csMoreFlexible>
  we want to bring back a lot of the flexibility
</build-note>

<build-note id=csStitching>
  of schema stitching
</build-note>

<build-note id=csProject>
  giving you more options for how to project large graphs.
</build-note>

<build-note id=csCompatibility>
  flexibility also means compatibility.

  this was an important design criteria: we absolutely did not want to introduce any mandatory changes on the client side. all the new shiny features we're about to talk about will work with existing graphql clients.

  everything we're talking about today will work with your current clients and your current federated services. but they'll also work with services that aren't currently federated. federation does require a bit of work: you have to declare keys and define entity resolvers. and you may still want to do this, even in the future! but you won't have to. constellation gives us tools to federate services that have not implemented federation! it lets us weave together graphs that have no idea they're in a federation at all.
</build-note>

<build-note id=csEnd>
  let's see how.
</build-note>

<script>
  When(buildInRange(csExplode, {order: Infinity}))
    .start(() => splode.resumeAnimation().graphData(blocks).zoomToFit())
    .end(() => splode.pauseAnimation())

  When(buildInRange(csExplode, {order: Infinity}))
    .withDuration(20[sec])
    .at(orbit(splode))

  const bullets = {
    csWhatsNext: 'project constellation:',
    csEvolution: ' federation next',
    csFaster: '\n    — faster',
    csRust: '\t\t\t\t🦀',
    csParallelism: ' ⚗️',
    csAheadOfTime: ' ⏱',
    csStronger: '\n    — stronger',
    csValidations: '\t\t\t✅',
    csErrors: ' 🔥',
    csInsight: ' 👁',
    csMoreFlexible: '\n    — more flexible',
    csStitching: '\t\t🧵',
    csProject: ' 📽',
    csCompatibility: ' 🔌',
  }

  let txt = ''
  for (const b of Object.keys(bullets)) {    
    txt = bullets[b] = txt + bullets[b]
  }

  When(csFlexiblier)
    .start(() =>
      whatsNextTxt.text = bullets.csInsight + '\n    — flexiblier')

  When(buildInRange(csWhatsNext, csEnd))
    .changed((_, current) => {
      if (!(current.id in bullets)) return
      whatsNextTxt.text = bullets[current.id]
    })
    .end(() => {
      whatsNextTxt.text = ''
    })
</script>

<build-note id=featBooks>
  let's go back and look at our books schema
</build-note>

<script>
  When(featBooks)
    .start(() => {
    })
</script>


<!-- Letterbox & Bug -->
<link rel=stylesheet href=bug.less>
<div id=bug>
  <a href=https://twitter.com/rakshesha>@rakshesha</a>
  <a class=visible href=https://ashi.io>ashi.io</a>
</div>
<script src=bug.js></script>
<!-- End Letterbox & Bug -->

<a style='display: none;' href=presenter.html></a>
<div id=letterbox-bar-1></div>
<div id=letterbox-bar-2></div>

